#!/usr/bin/env dls-python

# Simple script for setting the TMBF into the appropriate tune measurement
# mode.

from pkg_resources import require
require('cothread')
require('numpy')

import sys
import numpy
import argparse

from cothread import catools


DEFAULT_CONFIG = '/home/ops/diagnostics/config/TMBF_tune.config'

DEVICE_TO_AXIS = {
    'SR23C-DI-TMBF-01': 'X',
    'SR23C-DI-TMBF-02': 'Y',
    'TS-DI-TMBF-01': 'X',
}

VALID_SETUPS = ['TUNE', 'AP', 'SBFB']


def put(pv, value):
    catools.caput('%s:%s' % (DEVICE, pv), value)

def putwf(pv, value):
    put(pv, numpy.repeat(value, 936))

def get(pv, **kargs):
    return catools.caget('%s:%s' % (DEVICE, pv), **kargs)

def get_config(config, key):
    try:
        return config['%s_%s_%s' % (AXIS, key, RING_MODE)]
    except:
        print >>sys.stderr, 'Configuration for %s:%s in mode %s not found' % (
            DEVICE, key, RING_MODE)
        raise

def compute_filter_size(tune):
    N_TAPS = get('FIR:N_TAPS', datatype = int)

    # Search for best filter size.  In this search we prefer shorter filters
    # over longer filters.
    best_error = 1
    filter = (0, 0)
    for length in range(3, N_TAPS + 1):
        for cycles in range(1, length):
            error = abs(tune - float(cycles) / length)
            if error < best_error:
                best_error = error
                filter = (cycles, length)
    return filter

def apply_overrides(config_key):
    match = config_key + '_'
    l = len(match)
    for key in globals().keys():
        if key[:l] == match:
            print 'override:', key, globals().get(key[l:]), '<=', globals()[key]
            globals()[key[l:]] = globals()[key]

def update_globals(config, setup):
    # Use settings in config file to override defaults set here.
    globals().update(config)

    # Apply any ring mode/axis specific overrides (should only pick up cycles
    # and length overrides).
    apply_overrides('%s_%s' % (AXIS, RING_MODE))

    # Apply setup specific overrides.
    apply_overrides(setup)


# ------------------------------------------------------------------------------
# Argument parsing

parser = argparse.ArgumentParser(
    description = 'Configure device in specified setup mode.')
parser.add_argument(
    '-c', dest = 'config', default = DEFAULT_CONFIG,
    help = 'Alternative configuration file')
parser.add_argument(
    '-d', dest = 'debug', default = False, action = 'store_true',
    help = 'Enable debug mode')
parser.add_argument(
    '-m', dest = 'ring_mode', default = None,
    help = 'Specify ring mode, otherwise PV will be consulted')
parser.add_argument(
    '-t', dest = 'tune', default = None, type = float,
    help = 'Specify tune, otherwise config file will be consulted')
parser.add_argument('device', help = 'TMBF device name to configure')
parser.add_argument('setup',
    help = 'Configuration setup, must be one of TUNE, AP, SBFB')
args = parser.parse_args()

SETUP = args.setup

DEVICE = args.device
try:
    AXIS = DEVICE_TO_AXIS[DEVICE]
except:
    parser.error('Device \'%s\' not known' % DEVICE)
if SETUP not in VALID_SETUPS:
    parser.error('Setup mode \'%s\' is invalid' % SETUP)

if args.debug:
    def put(pv, value):
        print '%s <= %s' % (pv, value)
    def putwf(pv, value):
        print '%s <= 936*[%s]' % (pv, value)

if args.ring_mode is None:
    RING_MODE = catools.caget('SR-CS-RING-01:MODE', datatype = str)
else:
    RING_MODE = args.ring_mode


# Load the specified configuration file.  This contains overrides for the
# globals below together with settings for the mode specific default tune in a
# backwards compatible format.
CONFIG_FILE = args.config
CONFIG = {}
execfile(CONFIG_FILE, {}, CONFIG)

# Load tune from config file in its strange compatibility format
if args.tune is None:
    tune = float('0.%04d' % get_config(CONFIG, 'tune'))
else:
    tune = args.tune
cycles, length = compute_filter_size(tune)


# ------------------------------------------------------------------------------
# Defaults and configuration

harmonic = 80
bunch = 450

tune_threshold = 0.3
min_block_sep = 20
min_block_len = 20
sweep_dwell_time = 100

blanking_interval = 10000

sweep_range = 0.05
alarm_range = 0.01

dac_output = 0                # By default DAC output is off
bunch_mode = 'All Bunches'    # By default detect on all bunches
detector_input = 'FIR'


# Multibunch tune measurement
TUNE_sweep_gain = '-42dB'

# Feedback on, single bunch tune measurement
SBFB_sweep_gain = '-24dB'
SBFB_dac_output = 1    # Enable FIR output in this mode
SBFB_bunch_mode = 'Single Bunch'
SBFB_harmonic = 0

# Accelerator physics mode
AP_sweep_gain = '0dB'
AP_tune = 0.25
AP_sweep_range = 0.245
AP_alarm_range = 0.245
AP_detector_input = 'ADC'
AP_min_block_len = 5


# Apply configuration and mode specific settings
update_globals(CONFIG, SETUP)


# ------------------------------------------------------------------------------
# Write computed configuration

# First a bunch of sanity settings, in case somebody has been messing with
# stuff.
put('DAC:ENABLE_S', 'Off')        # Turn off while we mess with settings

# Make sure we're sane.
put('LOOPBACK_S', 'Normal')
put('COMPENSATE_S', 'Normal')
put('SEQ:0:BANK_S', 'Bank 0')
put('DET:RESET_WIN_S.PROC', 0)

# Ensure no triggers are running and the sequencer is stopped
put('TRG:DDR:RESET_S.PROC', 0)
put('TRG:BUF:RESET_S.PROC', 0)
put('SEQ:RESET_S.PROC', 0)

# Configure FIR as selected
put('FIR:0:LENGTH_S', length)
put('FIR:0:CYCLES_S', cycles)
put('FIR:0:USEWF_S', 'Settings')
put('FIR:GAIN_S', '-42dB')

# Configure bunch bank #0 for FIR and selected operation
putwf('BUN:0:FIRWF_S', 0)
putwf('BUN:0:OUTWF_S', dac_output)
putwf('BUN:0:GAINWF_S', 1)

# Configure sequencer
put('SEQ:1:HOLDOFF_S', 2)
put('SEQ:1:DWELL_S', sweep_dwell_time)
put('SEQ:1:GAIN_S', sweep_gain)
put('SEQ:1:ENWIN_S', 'Windowed')
put('SEQ:1:BLANK_S', 'Blanking')

# Configure detector
put('DET:MODE_S', bunch_mode)
put('DET:AUTOGAIN_S', 'Autogain')
put('DET:INPUT_S', detector_input)
put('DET:LOOP:ADC_S', 1)

# Configure tune measurement
put('TUNE:HARMONIC_S', harmonic)
put('TUNE:CENTRE_S', tune)
put('TUNE:RANGE_S', sweep_range)
put('TUNE:ALARM_S', alarm_range)
put('TUNE:BUNCH_S', bunch)
put('TUNE:SET_S.PROC', 0)

put('TUNE:BLK:LEN_S', min_block_len)
put('TUNE:BLK:SEP_S', min_block_sep)
put('TUNE:THRESHOLD_S', tune_threshold)

# Trigger on external trigger.
put('TRG:BUF:SEL_S', 'Hardware')
put('TRG:BUF:EXT:EN_S', 'Enable')
put('TRG:BUF:EXT:BL_S', 'Blanking')
put('TRG:BUF:ADC:EN_S', 'Ignore')
put('TRG:BUF:SCLK:EN_S', 'Ignore')
put('TRG:BUF:MODE_S', 'Retrigger')

put('TRG:SEQ:ENA_S', 'Enabled')
put('TRG:SYNC_S', 'Separate')
put('TRG:BLANKING_S', blanking_interval)

# Now we can go!
put('DAC:ENABLE_S', 'On')
put('TRG:BUF:ARM_S.PROC', 0)

# vim: set filetype=python:
